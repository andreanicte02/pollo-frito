/*----------------------------------------------------------------------------
--------------------- 1ra. Area: Codigo de Usuario
----------------------------------------------------------------------------*/

//-------------------> Importaciones
//-------------------> Paquetes
package com.polloenpelotas.AnalizadorCup;


import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.List;
import com.polloenpelotas.language.nodes.*;
import com.polloenpelotas.language.FileLocation;
import com.polloenpelotas.language.nodes.Instructions.*;
import com.polloenpelotas.language.nodes.ExpressionsOperations.*;
import com.polloenpelotas.language.nodes.CreateZTypes.*;

//-------------------> Codigo para el parser, variables, metodos
parser code
{:
    public String salida="";

    //-------------------> Metodo al que se llama automaticamente ante algun error sintactico.
    public void syntax_error(Symbol s)
    {
        String lexema = s.value.toString();
        int fila = s.right;
        int columna = s.left;

        System.out.println("!!!!!!! Error Sintactico Recuperado !!!!!!!");
        System.out.println("\t\tLexema: "+lexema);
        System.out.println("\t\tFila: "+fila);
        System.out.println("\t\tColumna: "+columna);
    }


    //-------------------> Metodo al que se llama en el momento en que ya no es posible una recuperacion de errores.
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {
        String lexema = s.value.toString();
        int fila = s.right;
        int columna = s.left;

        System.out.println("!!!!!!! Error Sintactico, Panic Mode!!!!!!!");
        System.out.println("\t\tLexema: "+lexema);
        System.out.println("\t\tFila: "+fila);
        System.out.println("\t\tColumna: "+columna);
    }


    public void semantic(Symbol cur_token, String n)
    {
        System.out.println("error semantico ");
    }


    public void semantic(String msg, Object obj) {}

:}


//-------------------> Codigo para las acciones gramaticales
action code
{:
:}


/*----------------------------------------------------------------------------
--------------------- 2da. Area: Declaraciones
----------------------------------------------------------------------------*/

//-------------------> Declaración de Terminales
terminal mas, menos, por, dividir, potenciar, modulo;
terminal igualQue, difQue, mayorQue, mayorIgualQue,menorQue, menorIgualQue;
terminal and, or, not;
terminal tern, dosp;
terminal apar, cpar, pComa, igual, abra, cbra, coma;
terminal String numero,decimal, identifier,truee, falsee, cadena;
terminal umenos;

terminal print;

//-------------------> Declaración de No Terminales
non terminal List<AstNode> inicio;
non terminal List<AstNode> sentenciasPrueba;

non terminal AstNode exp, asignacion;
non terminal AstNode sentenciaPrueba;
non terminal AstNode imprimir;
non terminal endSent;
non terminal AstNode crearVector;
non terminal List<AstNode> listExp;
non terminal List<AstNode> exps;


//-------------------> Indicar precedencia(de menor a mayor) y asociatividad
precedence right igual;
precedence right tern, dosp;
precedence left or;
precedence left and;
precedence left igualQue, difQue;
precedence left mayorQue,menorQue, mayorIgualQue,menorIgualQue;

precedence left mas, menos;
precedence left por, dividir, modulo;
precedence left potenciar;
precedence right not, umenos;
precedence left abra;


//-------------------> No Terminal inicial
start with inicio;


/*-------------------------------------------------------------------
--------------------- 3ra. y ultima area: Reglas Sintacticas
-------------------------------------------------------------------*/

inicio::= sentenciasPrueba:a  {: RESULT = a; :};


sentenciasPrueba::= sentenciasPrueba:a sentenciaPrueba:b    {: RESULT= a; RESULT.add(b); :}
            |sentenciaPrueba:a              {: RESULT = new ArrayList<>(); RESULT.add(a); :};

sentenciaPrueba::= asignacion:a             {: RESULT = a; :}
               |imprimir:a                  {: RESULT = a; :};

asignacion::= exp:a igual:o exp:b endSent     {: RESULT = new AssignAstNode(new FileLocation(oleft, oright),a,b); :};

imprimir ::= print apar exp:e cpar endSent    {: RESULT = new PrintAstNode(new FileLocation(eleft, eright),e); :};

endSent::= pComa
        |
        ;

exp::= exp:a mas:o exp:b            {: RESULT = new AddAstNode(new FileLocation(oleft, oright),a,b); :}

    | exp:a menos exp:b             {: RESULT = new RestAstNode(new FileLocation(aleft, aright), a,b); :}

    | exp:a modulo exp:b            {: RESULT = new ModAstNode(new FileLocation(aleft, aright), a,b); :}
    | exp:a por exp:b               {: RESULT = new MultAstNode(new FileLocation(aleft, aright), a,b); :}
    | exp:a dividir exp:b           {: RESULT = new DivAstNode(new FileLocation(aleft, aright), a,b); :}

    | exp:a potenciar exp:b         {: RESULT = new PotAstNode(new FileLocation(aleft, aright), a,b); :}

    | exp:a igualQue exp:b          {: RESULT = new EqualToAstNode(new FileLocation(aleft, aright), a,b); :}
    | exp:a difQue exp:b            {: RESULT = new NotEqualToAstNode(new FileLocation(aleft, aright), a,b); :}

    | exp:a menorIgualQue exp:b     {: RESULT = new MenorIgualAstNode (new FileLocation(aleft, aright), a,b); :}
    | exp:a mayorIgualQue exp:b     {: RESULT = new MayorIgualAstNode (new FileLocation(aleft, aright), a,b); :}
    | exp:a mayorQue exp:b          {: RESULT = new MayorAstNode(new FileLocation(aleft, aright), a,b); :}
    | exp:a menorQue exp:b          {: RESULT = new MenorAstNode(new FileLocation(aleft, aright), a,b); :}

    | exp:a and exp:b               {: RESULT = new AndAstNode(new FileLocation(aleft, aright), a,b); :}
    | exp:a or exp:b                {: RESULT = new OrAstNode (new FileLocation(aleft, aright), a,b);  :}

    | apar exp:e cpar               {: RESULT =  e; :}


    | not exp:a                     {: RESULT = new NotAstNode(new FileLocation(aleft, aright),a); :}
    | menos exp:a                   {: RESULT = new UnaryMinusNode(new FileLocation(aleft, aright), a); :} %prec umenos

    | cadena:a                      {: RESULT = new CreateZStringNode(new FileLocation(aleft, aright),a ); :}
    | decimal:a                     {: RESULT = new CreateZNumericNode (new FileLocation(aleft, aright), Double.parseDouble(a )); :}
    | numero:a                      {: RESULT = new CreateZIntegerNode(new FileLocation(aleft, aright),Integer.parseInt(a)); :}

    | truee:a                       {: RESULT = new CreateZBooleanNode (new FileLocation(aleft, aright), true);  :}
    | falsee:a                      {: RESULT = new CreateZBooleanNode (new FileLocation(aleft, aright), false); :}

    | identifier:a                  {: RESULT = new FindIDAstNode(new FileLocation(aleft, aright),a); :}

    | crearVector:a                 {: RESULT = a; :}
    | exp:a abra exp:b cbra         {: RESULT = new AccessVectorAstNode(new FileLocation(aleft, aright),a,b); :}
    ;


crearVector::= abra listExp:a cbra {: RESULT = new CreateZVectorNode(new FileLocation(aleft, aright), a); :}
            ;


listExp::= exps:a           {: RESULT = a; :}
                |           {: RESULT = new ArrayList<>(); :}
                ;

exps::= exps:a coma exp:b   {: RESULT = a; RESULT.add(b); :}
            | exp:a         {: RESULT = new ArrayList<>(); RESULT.add(a); :}
            ;



