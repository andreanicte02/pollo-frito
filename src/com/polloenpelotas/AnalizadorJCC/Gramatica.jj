options {
  IGNORE_CASE = true;
  STATIC = false;
}

PARSER_BEGIN(Gramatica)
/** Analizador de expresiones aritmeticas sencillas. */

package com.polloenpelotas.AnalizadorJCC;

import java.util.ArrayList;
import java.util.List;
import com.polloenpelotas.language.nodes.*;
import com.polloenpelotas.language.FileLocation;
import com.polloenpelotas.language.nodes.Instructions.*;
import com.polloenpelotas.language.nodes.ExpressionsOperations.*;
import com.polloenpelotas.language.nodes.CreateZTypes.*;


public class Gramatica {
}

PARSER_END(Gramatica)


/**********************************************************
                            Lexico
***********************************************************/

/** Lexico */
SKIP : {
      " "
    | "\t"
    | "\r"
    | "\n"
}

TOKEN : {
      <NUMERO: (["0"-"9"])+>
    | <DECIMAL: (["0"-"9"])+"."(["0"-"9"])+>
    | <PCOMA: ";">
    | <PARENI: "(">
    | <PAREND: ")">
    | <MAS: "+">
    | <MENOS: "-">
    | <POR: "*">
    | <DIV: "/">
    | <POT: "^">
    | <MENORQUE: "<">
    | <MAYORQUE: ">">
    | <MENORIGUAL: "<=">
    | <MAYORIGUAL: ">=">
    | <IGUAL: "=">
    | <ARROW: "=>">
    | <IGUALACION: "==">
    | <DIFERENCIACION: "!=">
    | <AND: "&">
    | <OR: "|">
    | <NOT: "!" >
    | <MODULAR: "%%">
    | <ABRA: "[">
    | <CBRA: "]">
    | <TRUE: "true">
    | <FALSE: "false">
    | <COMA: ",">
    | <ALLA: "{">
    | <CLLA: "}">
    | <NOTHING: "null">
    | <RETURN: "return">
    | <FUNCTION: "function">
    | <IDENTIFIER: (["a"-"z","A"-"Z"]|["."]["a"-"z","A"-"Z"]) (["a"-"z","A"-"Z", "_", "." ]|["0"-"9"])*>


}
/** Fin Lexico */

MORE :
{
    "\"" :STRING_STATE
}

<STRING_STATE> MORE:
{
    <~["\""]>
}

<STRING_STATE> TOKEN:
{
   <STRING:"\""> : DEFAULT
}
/** ProducciÃ³n inicial
    Analizar -> (Instruccion)+ EOF
*/


List<AstNode>  analizar() :
{AstNode e; List<AstNode> l = new ArrayList<AstNode>(); }
{
  (e=instruccion() {l.add(e);})+ <EOF> {return l;}
}


AstNode instruccion() :
{AstNode e, e1;}S
{

  LOOKAHEAD(2)e=ExpsLeft() <IGUAL> e1=ExpresionOr() (<PCOMA>)? {return new AssignAstNode(new FileLocation(token.beginColumn, token.beginLine),e, e1); }
  |
  LOOKAHEAD(2)e=invokeFunction()   (<PCOMA>)?   { return e; }
  |
  LOOKAHEAD(1)e=sentReturn()      (<PCOMA>)?   { return e; }
  |
  LOOKAHEAD(3)e=funcionNormal()       {return e;}
  |
  LOOKAHEAD(6)e=funcionFlecha()       {return e;}

}

List<AstNode>  listaInstruccion():
{ AstNode e; List<AstNode> l = new ArrayList<AstNode>(); }
{
    (e=instruccion(){l.add(e);})+    {return l;}
    |                                {return l;}
}

AstNode funcionNormal():
{Token t; List<AstNode> lPar = new ArrayList<AstNode>(); List<AstNode> lSent = new ArrayList<AstNode>(); }
{
    t=<IDENTIFIER> <IGUAL> <FUNCTION> <PARENI> lPar=exps() <PAREND> <ALLA> lSent=listaInstruccion() <CLLA>
    {
        AstNode aux1= new FindIDLeftAstNode(new FileLocation(t.beginColumn, t.beginLine), t.image );
        AstNode aux2= new DeclararFuncionAstNode(new FileLocation(token.beginColumn, token.beginLine), lPar, lSent);


        return new AssignFunctionAstNode(new FileLocation(token.beginColumn, token.beginLine), aux1, aux2);

    }
}

AstNode funcionFlecha():
{Token t; List<AstNode> lPar = new ArrayList<AstNode>(); List<AstNode> lSent = new ArrayList<AstNode>(); }
{
    t=<IDENTIFIER> <IGUAL> <PARENI> lPar=exps() <PAREND> <ARROW> <ALLA> lSent=listaInstruccion() <CLLA>
    {
        AstNode aux1= new FindIDLeftAstNode(new FileLocation(t.beginColumn, t.beginLine), t.image );
        AstNode aux2= new DeclararFuncionAstNode(new FileLocation(token.beginColumn, token.beginLine), lPar, lSent);


        return new AssignFunctionAstNode(new FileLocation(token.beginColumn, token.beginLine), aux1, aux2);

    }
}

AstNode sentReturn():
{AstNode e=null;}
{
    LOOKAHEAD(2)<RETURN> e=ExpresionOr() {return new ReturnAstNode(new FileLocation(token.beginColumn, token.beginLine),e); }
    |
    LOOKAHEAD(1)<RETURN>

}




AstNode ExpresionOr():
{AstNode e, e1;}
{

    e=ExpresionAnd()
    (
        <OR> e1=ExpresionAnd() { e = new OrAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }

    )*
    {return e;}

}


AstNode ExpresionAnd():
{AstNode e, e1;}
{

    e=ExpresionIgualdad()
    (
        <AND> e1=ExpresionIgualdad() { e = new AndAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }

    )*
    {return e;}

}


AstNode ExpresionIgualdad():
{AstNode e, e1;}
{

    e=ExpresionRelacional()
    (
        <IGUALACION> e1=ExpresionRelacional() { e = new EqualToAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        <DIFERENCIACION> e1=ExpresionRelacional() { e = new NotEqualToAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }

    )*
    {return e;}

}

AstNode ExpresionRelacional():
{AstNode e, e1;}
{

    e=ExpresionSuma()
    (
        <MAYORQUE> e1=ExpresionSuma() { e = new MayorAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        <MENORQUE> e1=ExpresionSuma() { e = new MenorAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        <MAYORIGUAL> e1=ExpresionSuma() { e = new MayorIgualAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        <MENORIGUAL> e1=ExpresionSuma() { e = new MenorIgualAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }


    )*
    {return e;}

}

AstNode ExpresionSuma() :
{AstNode e, e1;}
{
    e=ExpresionMultiplicativa()
    (
        <MAS> e1=ExpresionMultiplicativa() { e = new AddAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        <MENOS> e1=ExpresionMultiplicativa() { e = new RestAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }

    )*
    {return e;}
}


AstNode ExpresionMultiplicativa() :
{AstNode e, e1;}
{
    e=ExpPotencia()
    (
        <POR> e1=ExpPotencia() { e = new MultAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        <DIV> e1=ExpPotencia() { e = new DivAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        <MODULAR> e1=ExpPotencia() { e = new ModAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }


    )*
    {return e;}
}

AstNode ExpPotencia():
{AstNode e, e1;}{

    e=ExpresionUnaria()
    (
        <POT> e1= ExpresionUnaria() { e = new PotAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }

    )*

    {return e;}
}

AstNode ExpresionUnaria() :
{AstNode e;}
{
    <MENOS> e=ExpresionUnaria() { return new UnaryMinusNode(new FileLocation(token.beginColumn, token.beginLine), e); }
    |
    <NOT> e=ExpresionUnaria()   { return new NotAstNode(new FileLocation(token.beginColumn, token.beginLine), e); }
    |
    e=ExpAccess() {return e;}
}

AstNode ExpAccess():
{AstNode e, e1;}
{
   e=Primitives()(

        LOOKAHEAD(2) <ABRA> e1=ExpresionOr() <CBRA>
        {e = new AccessStructAstNode (new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        LOOKAHEAD(2) <ABRA> <ABRA> e1=ExpresionOr() <CBRA> <CBRA>
        {e = new Access2ListAstNode (new FileLocation(token.beginColumn, token.beginLine),e,e1);}

   )* {return e;}

}


AstNode Primitives() :
{AstNode e; Token t;   }
{
    <PARENI> e = ExpresionOr() <PAREND>   { return e; }
    |
    <NUMERO>  { return new CreateZIntegerNode(new FileLocation(token.beginColumn, token.beginLine),Integer.parseInt( token.image )); }
    |
    <DECIMAL> { return new CreateZNumericNode (new FileLocation(token.beginColumn, token.beginLine), Double.parseDouble(token.image )); }
    |
    <TRUE>  { return new CreateZBooleanNode(new FileLocation(token.beginColumn, token.beginLine),true); }
    |
    <FALSE> { return new CreateZBooleanNode(new FileLocation(token.beginColumn, token.beginLine),false); }
    |
    t=<STRING> { return new CreateZStringNode(new FileLocation(token.beginColumn, token.beginLine), t.image.substring(1,t.image.length()-1) ); }
    |
    LOOKAHEAD(2) e=invokeFunction() {return e;}
    |
    <NOTHING> { return new CreateZNothingNode(new FileLocation(token.beginColumn, token.beginLine));}
    |
    t=<IDENTIFIER> {return new FindIDAstNode(new FileLocation(t.beginColumn, t.beginLine), t.image ); }


}

AstNode invokeFunction():
{List<AstNode> l = new ArrayList<AstNode>(); Token t; }
{
     t=<IDENTIFIER> <PARENI> l=exps() <PAREND> {return new InvocarFuncionAstNode(new FileLocation(t.beginColumn, t.beginLine),t.image, l); }
}



List<AstNode> exps():
{ AstNode e,e1;  List<AstNode> l = new ArrayList<AstNode>(); }
{
    e=ExpresionOr() { l.add(e); } (

        <COMA> e1=ExpresionOr() { l.add(e1); }

    )* {return l;}
    |
    {return l;}
}

AstNode ExpsLeft():
{AstNode e, e1; }
{
    e=PrimitivesLeft()  (
        LOOKAHEAD(2) <ABRA> e1=ExpresionOr() <CBRA>
        {e = new LeftAccess1AstNode (new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
         LOOKAHEAD(2) <ABRA> <ABRA> e1=ExpresionOr() <CBRA> <CBRA>
        {e = new LeftAccess2AstNode (new FileLocation(token.beginColumn, token.beginLine),e,e1);}

    )* { return e;}


}

AstNode PrimitivesLeft():
{Token t;}
{
    t=<IDENTIFIER> {return new FindIDLeftAstNode(new FileLocation(t.beginColumn, t.beginLine), t.image ); }
}

List<AstNode>  parametros():
{AstNode e, e1; List<AstNode> l = new ArrayList<AstNode>();}
{
    e=parametro() {l.add(e); }(
        <COMA> e1=parametro(){ l.add(e1); }
    )* {return l;}
    |
    {return l;}
}

AstNode parametro():
{AstNode e; Token t;}
{
    LOOKAHEAD(1)  t=<IDENTIFIER>
    {
        return new DeclararParametroAstNode(new FileLocation(token.beginColumn, token.beginLine), t.image,
            new CreateZNothingNode(new FileLocation(token.beginColumn, token.beginLine)));
     }
    |
    LOOKAHEAD(2) t=<IDENTIFIER> <IGUAL> e=ExpresionOr()
    {
        return new DeclararParametroAstNode(new FileLocation(token.beginColumn, token.beginLine), t.image, e);
    }
}