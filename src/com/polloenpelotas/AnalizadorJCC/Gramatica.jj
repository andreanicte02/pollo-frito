options {
  IGNORE_CASE = true;
  STATIC = false;
}

PARSER_BEGIN(Gramatica)
/** Analizador de expresiones aritmeticas sencillas. */

package com.polloenpelotas.AnalizadorJCC;

import java.util.ArrayList;
import java.util.List;
import com.polloenpelotas.language.nodes.*;
import com.polloenpelotas.language.FileLocation;
import com.polloenpelotas.language.nodes.Instructions.*;
import com.polloenpelotas.language.nodes.ExpressionsOperations.*;


public class Gramatica {
}

PARSER_END(Gramatica)


/**********************************************************
                            Lexico
***********************************************************/

/** Lexico */
SKIP : {
      " "
    | "\t"
    | "\r"
    | "\n"
}

TOKEN : {
      <NUMERO: (["0"-"9"])+>
    | <DECIMAL: (["0"-"9"])+"."(["0"-"9"])+>
    | <PRINT: "print">
    | <PCOMA: ";">
    | <PARENI: "(">
    | <PAREND: ")">
    | <CORI: "[">
    | <CORD: "]">
    | <MAS: "+">
    | <MENOS: "-">
    | <POR: "*">
    | <DIV: "/">
    | <POT: "^">
    | <MENORQUE: "<">
    | <MAYORQUE: ">">
    | <MENORIGUAL: "<=">
    | <MAYORIGUAL: ">=">
    | <IGUALACION: "==">
    | <DIFERENCIACION: "!=">
    | <AND: "&">
    | <OR: "|">
    | <NOT: "!" >
    | <MODULAR: "%%">
    | <TRUE: "true">
    | <FALSE: "false">


}
/** Fin Lexico */

MORE :
{
    "\"" :STRING_STATE
}

<STRING_STATE> MORE:
{
    <~["\""]>
}

<STRING_STATE> TOKEN:
{
   <STRING:"\""> : DEFAULT
}
/** ProducciÃ³n inicial
    Analizar -> (Instruccion)+ EOF
*/
List<AstNode>  Analizar() :
{AstNode e; List<AstNode> l = new ArrayList<AstNode>(); }
{
  (e=Instruccion() {l.add(e);})+ <EOF> {return l;}
}


AstNode Instruccion() :
{AstNode e;}
{
  <PRINT> <PARENI> e=ExpresionOr() <PAREND> (<PCOMA>)?  { return new PrintAstNode(new FileLocation(token.beginColumn, token.beginLine),e); }
}


AstNode ExpresionOr():
{AstNode e, e1;}
{

    e=ExpresionAnd()
    (
        <OR> e1=ExpresionAnd() { e = new OrAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }

    )*
    {return e;}

}


AstNode ExpresionAnd():
{AstNode e, e1;}
{

    e=ExpresionIgualdad()
    (
        <AND> e1=ExpresionIgualdad() { e = new AndAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }

    )*
    {return e;}

}


AstNode ExpresionIgualdad():
{AstNode e, e1;}
{

    e=ExpresionRelacional()
    (
        <IGUALACION> e1=ExpresionRelacional() { e = new EqualToAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        <DIFERENCIACION> e1=ExpresionRelacional() { e = new NotEqualToAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }

    )*
    {return e;}

}

AstNode ExpresionRelacional():
{AstNode e, e1;}
{

    e=ExpresionSuma()
    (
        <MAYORQUE> e1=ExpresionSuma() { e = new MayorAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        <MENORQUE> e1=ExpresionSuma() { e = new MenorAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        <MAYORIGUAL> e1=ExpresionSuma() { e = new MayorIgualAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        <MENORIGUAL> e1=ExpresionSuma() { e = new MenorIgualAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }


    )*
    {return e;}

}

AstNode ExpresionSuma() :
{AstNode e, e1;}
{
    e=ExpresionMultiplicativa()
    (
        <MAS> e1=ExpresionMultiplicativa() { e = new AddAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        <MENOS> e1=ExpresionMultiplicativa() { e = new RestAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }

    )*
    {return e;}
}


AstNode ExpresionMultiplicativa() :
{AstNode e, e1;}
{
    e=ExpPotencia()
    (
        <POR> e1=ExpPotencia() { e = new MultAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        <DIV> e1=ExpPotencia() { e = new DivAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }
        |
        <MODULAR> e1=ExpPotencia() { e = new ModAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }


    )*
    {return e;}
}

AstNode ExpPotencia():
{AstNode e, e1;}{

    e=ExpresionUnaria()
    (
        <POT> e1= ExpresionUnaria() { e = new PotAstNode(new FileLocation(token.beginColumn, token.beginLine),e,e1); }

    )*

    {return e;}
}

AstNode ExpresionUnaria() :
{AstNode e;}
{
    <MENOS> e=ExpresionUnaria() { return new UnaryMinusNode(new FileLocation(token.beginColumn, token.beginLine), e); }
    |
    <NOT> e=ExpresionUnaria()   { return new NotAstNode(new FileLocation(token.beginColumn, token.beginLine), e); }
    |
    e=Primitivo() {return e;}
}


AstNode Primitivo() :
{AstNode e; Token t;}
{
    <NUMERO>  { return new CreateZIntegerNode(new FileLocation(token.beginColumn, token.beginLine),Integer.parseInt( token.image )); }
    | <DECIMAL> { return new CreateZNumericNode (new FileLocation(token.beginColumn, token.beginLine), Double.parseDouble(token.image )); }
    | <TRUE>  { return new CreateZBooleanNode(new FileLocation(token.beginColumn, token.beginLine),true); }
    | <FALSE> { return new CreateZBooleanNode(new FileLocation(token.beginColumn, token.beginLine),false); }
    | t=<STRING> { return new CreateZStringNode(new FileLocation(token.beginColumn, token.beginLine), t.image.substring(1,t.image.length()-1) ); }
    | <PARENI> e = ExpresionOr() <PAREND>   { return e; }


}